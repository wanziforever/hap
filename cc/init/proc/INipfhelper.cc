// INipfhelper.C
//
// Uses IPF on Solaris, IPTABLES on Linux

/* IBM wyoes 20060508 added sys/stat.h for umask prototype */
#include <sys/stat.h>

#include "cc/hdr/cr/CRdebugMsg.hh"
#include "cc/hdr/db/DBretval.hh"
#include "cc/hdr/db/DBintfcFuncs.hh"
#include "cc/hdr/db/DBopDriver.hh"
#include "cc/init/proc/INipfhelper.hh"
#define lint
#include <errno.h>
#include <stdio.h>
#include <string>
#include <set>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h> /* for gethostbyname() */


/* IBM waynepar 20070313 iptables support for SuSe Linux */
#ifdef __linux

// SuSe Linux IPTABLE stuff

// keywords used in the iptables.conf file
#define PASS_IN "iptables -A INPUT  -j ACCEPT -p tcp -s "
#define PASS_OUT "iptables -A OUTPUT -j ACCEPT -p tcp -d "
#define BLOCK_IN "iptables -A INPUT  -j DROP -p tcp -s "
#define BLOCK_OUT "iptables -A OUTPUT -j DROP -p tcp -d "
#define TO ""
#define ANY ""
#define NONE ""
#define QUICK ""
#define PORT " --dport "
#define IN "IN"
#define OUT "OUT"
#define TTPORT "14502"
#define TTPORT2 "14510"

#define IPF_CONF "/etc/iptables.conf"    // the file where rules are stored
#define APPLY_RULE "/etc/iptables.conf"  // actually an executable script
#define MKEXE "chmod 0755 /etc/iptables.conf"

#define HEADER "\
###########################################################\n\
# This filter is used to block traffic for Oracle & TimesTen.\n\
# It is automatically generated by ipfmon process.\n\
# The content of this filter is generated from SERVICE_ACCESS table.\n\
# Don't try to change the content of this file manually\n\
###########################################################\n\
iptables --flush\n\
iptables -A INPUT  -j ACCEPT\n\
iptables -A OUTPUT -j ACCEPT\n\
iptables -A INPUT  -j DROP   -p tcp                    --dport 1521\n\
iptables -A OUTPUT -j DROP   -p tcp                    --dport 1521\n\
iptables -A INPUT  -j DROP   -p tcp                    --dport 5333\n\
iptables -A OUTPUT -j DROP   -p tcp                    --dport 5333\n\
iptables -A INPUT  -j DROP   -p tcp                    --dport 14502\n\
iptables -A OUTPUT -j DROP   -p tcp                    --dport 14502\n\
iptables -A INPUT  -j DROP   -p tcp                    --dport 14510\n\
iptables -A OUTPUT -j DROP   -p tcp                    --dport 14510\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.150.84  --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.150.84  --dport 5333\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.150.85  --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.150.85  --dport 5333\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.150.108 --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.150.108 --dport 5333\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.151.84  --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.151.84  --dport 5333\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.151.85  --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.151.85  --dport 5333\n\
iptables -A INPUT  -j ACCEPT -p tcp -s 192.168.151.108 --dport 5333\n\
iptables -A OUTPUT -j ACCEPT -p tcp -d 192.168.151.108 --dport 5333\n"


/* 
 * We hardcode the IP address(s) of the lead machine here 192.168.150.108
 * and 192.168.151.108 (they are interal network addresses and dont change based
 * on the site or network in which MAS resides) so that JDBCODBC connections
 * are allowed from ACTIVE to lead to platformDB (PostgreSql).
 * Using RC/V to update these using SERVICE_ACCESS form does not work since
 * these chanegs are not porpograted to ACTIVE (ipfmon only rns on LEAD).
 * this string dhould be kept in synch with what is in:
       cc/vendor/Firewall/NR/ipf.POST
 * this will be used to generate default /etc/ipf.conf file that is delivered
 */

#define TAILER ""

#else

// Solaris IPF stuff

// keywords used in the ipf.conf file
#define PASS_IN "pass in quick proto tcp from "
#define PASS_OUT "pass out quick proto tcp from "
#define BLOCK_IN "block in quick proto tcp from "
#define BLOCK_OUT "block out quick proto tcp from "
#define TO " to "
#define ANY "any"
#define NONE "none"
#define QUICK "quick"
#define PORT " port = "
#define IN "IN"
#define OUT "OUT"
#define TTPORT "14502"
#define TTPORT2 "14510"

#define IPF_CONF "/etc/ipf.conf"  // the file where rules are stored
#define APPLY_RULE "/sbin/ipf -F a -f /etc/ipf.conf"  // -F a flush the old rules

#define HEADER "\
###########################################################\n\
# This filter is used to block traffic for Oracle & TimesTen.\n\
# It may also include lines from custom.conf see cust doc for details.\n\
# It is automatically generated by ipfmon process.\n\
# The content of this filter is generated from SERVICE_ACCESS table.\n\
# Don't try to change the content of this file manually\n\
###########################################################\n\
count in all\n"


/* 
 * We hardcode the IP address(s) of the lead machine here 192.168.150.108
 * and 192.168.151.108 (they are interal network addresses and dont change based
 * on the site or network in which MAS resides) so that JDBCODBC connections
 * are allowed from ACTIVE to lead to platformDB (PostgreSql).
 * Using RC/V to update these using SERVICE_ACCESS form does not work since
 * these chanegs are not porpograted to ACTIVE (ipfmon only rns on LEAD).
 * this string dhould be kept in synch with what is in:
       cc/vendor/Firewall/NR/ipf.POST
 * this will be used to generate default /etc/ipf.conf file that is delivered
 */

#define TAILER "\
pass out quick proto tcp from any to 192.168.150.108 port = 5333\n\
pass out quick proto tcp from any to 192.168.151.108 port = 5333\n\
pass out quick proto tcp from any to 192.168.150.84 port = 5333\n\
pass out quick proto tcp from any to 192.168.151.84 port = 5333\n\
pass out quick proto tcp from any to 192.168.150.85 port = 5333\n\
pass out quick proto tcp from any to 192.168.151.85 port = 5333\n\
pass in quick proto tcp from any to 192.168.150.108 port = 5333\n\
pass in quick proto tcp from any to 192.168.151.108 port = 5333\n\
pass in quick proto tcp from any to 192.168.150.84 port = 5333\n\
pass in quick proto tcp from any to 192.168.151.84 port = 5333\n\
pass in quick proto tcp from any to 192.168.150.85 port = 5333\n\
pass in quick proto tcp from any to 192.168.151.85 port = 5333\n\
block in quick proto tcp from any to any port = 1521\n\
block in quick proto tcp from any to any port = 14502\n\
block in quick proto tcp from any to any port = 14510\n\
block in quick proto tcp from any to any port = 5333\n\
block out quick proto tcp from any to any port = 1521\n\
block out quick proto tcp from any to any port = 14502\n\
block out quick proto tcp from any to any port = 14510\n\
block out quick proto tcp from any to any port = 5333\n\
pass in quick all\n\
pass out quick all\n"  // blocks unwanted JDBC/ODBC accesses by default

#endif
/* IBM waynepar 20070313 end change */

#define UP      1;
#define DOWN    0;

Bool INcheckStatusIpfilter();

class RuleTuple
{
  public:
    RuleTuple( const char* ip, const char* port, const char* direction )
    {
      this->ip = ip;
      this->port = port;
      this->direction = direction;
    }
      // copy constructor
    RuleTuple( const RuleTuple& r )
    {
      ip = r.ip;
      port = r.port;
      direction = r.direction;
    }
    std::string ip;
    std::string port;
    std::string direction;
};

struct ltRuleTuple
{
  bool operator()( const RuleTuple r1, const RuleTuple r2) const
  {
    if ( r1.ip < r2.ip )
      return true;
    else if ( r1.ip > r2.ip )
      return false;
    else if ( r1.port < r2.port )
      return true;
    else if ( r1.port > r2.port )
      return false;
    else if ( r1.direction < r2.direction )
      return true;
    else 
      return false;
  }
};

std::set< RuleTuple, ltRuleTuple > ruleSet;

String rules;  // intermediate storage for getTupleHandler()
String repRules;  // intermediate storage for repTupleHandler()

String formLogicalName;  // stores the logical_name of the currently access form
String formProtocol;  // stores the protocol of the currently access form
String formHost;  // stores the service_host of the currently access form

DBRETVAL repTupleHandler(DBuserOpTag tag, char*& retResult, DBtuple& tuple);

IPFhelper::IPFhelper()
{
  ruleSet.clear();
}
  // this is a callback function, it receives a tuple from DBopDriver
DBRETVAL getTupleHandler(DBuserOpTag tag, char*& retResult, DBtuple& tuple)
{


    String logicalName = tuple[ "LOGICAL_NAME" ]->getValue();
    String protocol = tuple[ "PROTOCOL" ]->getValue();
    String host = tuple[ "SERVICE_HOST" ]->getValue();

CRDEBUG(0,("logicalName = %s protocol = %s host = %s",
    (const char*) logicalName,
    (const char*) protocol,
    (const char*) host));

      	// skip the record which is being accessed currently
    	if ( (logicalName == formLogicalName) && 
	     (protocol == formProtocol)       && 
	     (host == formHost) )
	{
      		return DBSUCCESS;
   	} 

    String host2 = tuple[ "SERVICE_HOST_2" ]->getValue();
    String host3 = tuple[ "SERVICE_HOST_3" ]->getValue();
    String host4 = tuple[ "SERVICE_HOST_4" ]->getValue();
    String portno = tuple[ "PORT_NO" ]->getValue();
    String inout = tuple[ "IN_OR_OUT" ]->getValue();
    String allow = tuple[ "ALLOW_DENY" ]->getValue();

      // get the rules for this record
    rules += IPFhelper::handleOneRecord( host, host2, host3, host4, inout, portno, allow );

    return DBSUCCESS;
}

String IPFhelper::handleOneRecord( String host, String host2, String host3, 
				   String host4, String inout, String portno,
				   String allow	)
{
CRDEBUG( CRinit, 
	( "IPFhelper::handleOneRecord(): host=%s, inout=%s, portno=%s allow=%s",
	(const char *)host, (const char *)inout, (const char *)portno,
	(const char*)allow) );

	String lineStr="";
  	//make a special case for port 113 identd
  	if ( portno == "113" )
  	{
  		if ( inout == "IN" )
		{
			if( allow == "A" )
			{
      				lineStr += PASS_IN;
      				lineStr += host;
      				lineStr += TO;
      				lineStr += ANY;
      				lineStr += PORT;
      				lineStr += portno;
      				lineStr += "\n";
			}
			else
			{
      				lineStr += BLOCK_IN;
      				lineStr += host;
      				lineStr += TO;
      				lineStr += ANY;
      				lineStr += PORT;
      				lineStr += portno;
      				lineStr += "\n";
			}
		}
		else //inout = OUT
		{
			if( allow == "A" )
			{
      				lineStr += PASS_OUT;
      				lineStr += host;
      				lineStr += TO;
      				lineStr += ANY;
      				lineStr += PORT;
      				lineStr += portno;
      				lineStr += "\n";
			}
			else
			{
      				lineStr += BLOCK_OUT;
      				lineStr += host;
      				lineStr += TO;
      				lineStr += ANY;
      				lineStr += PORT;
      				lineStr += portno;
      				lineStr += "\n";
			}
		}
  	}
  	//end special case for port 113 identd

  if (( inout == IN ) && ( portno != "113" ))
  {
    RuleTuple temp( ( const char* )host, ( const char* )portno, IN );
    RuleTuple temp2( ( const char* )host2, ( const char* )portno, IN );
    RuleTuple temp3( ( const char* )host3, ( const char* )portno, IN );
    RuleTuple temp4( ( const char* )host4, ( const char* )portno, IN );

    if ( host != "" && ruleSet.find( temp ) == ruleSet.end() )
    {
      lineStr += PASS_IN;
      lineStr += host;
      lineStr += TO;
      lineStr += ANY;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp );
    }
    if ( host2 != "" && ruleSet.find( temp2 ) == ruleSet.end() )
    {
      lineStr += PASS_IN;
      lineStr += host2;
      lineStr += TO;
      lineStr += ANY;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp2 );
    }
    if ( host3 != "" && ruleSet.find( temp3 ) == ruleSet.end() )
    {
      lineStr += PASS_IN;
      lineStr += host3;
      lineStr += TO;
      lineStr += ANY;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp3 );
    }
    if ( host4 != "" && ruleSet.find( temp4 ) == ruleSet.end() )
    {
      lineStr += PASS_IN;
      lineStr += host4;
      lineStr += TO;
      lineStr += ANY;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp4 );
    }
  }
  else if (( inout == OUT ) && ( portno != "113" ))
  {
    RuleTuple temp( ( const char* )host,  ( const char* )portno, OUT );
    RuleTuple temp2( ( const char* )host2, ( const char* )portno, OUT );
    RuleTuple temp3( ( const char* )host3, ( const char* )portno, OUT );
    RuleTuple temp4( ( const char* )host4, ( const char* )portno, OUT );

    if ( host != "" && ruleSet.find( temp ) == ruleSet.end() )
    {
      lineStr += PASS_OUT;
      lineStr += ANY;
      lineStr += TO;
      lineStr += host;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp );
    }
    if ( host2 != "" && ruleSet.find( temp2 ) == ruleSet.end() )
    {
      lineStr += PASS_OUT;
      lineStr += ANY;
      lineStr += TO;
      lineStr += host2;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp2 );
    }
    if ( host3 != "" && ruleSet.find( temp3 ) == ruleSet.end() )
    {
      lineStr += PASS_OUT;
      lineStr += ANY;
      lineStr += TO;
      lineStr += host3;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp3 );
    }
    if ( host4 != "" && ruleSet.find( temp4 ) == ruleSet.end() )
    {
      lineStr += PASS_OUT;
      lineStr += ANY;
      lineStr += TO;
      lineStr += host4;
      lineStr += PORT;
      lineStr += portno;
      lineStr += "\n";
      ruleSet.insert( temp4 );
    }
  }
 
 CRDEBUG( CRinit, ( "IPFhelper::handleOneRecord(): linestr is %s ",(const char *)lineStr) );
  return lineStr;

}


  // returns the rules
  // if error happened, the returned string starts from "ERROR"
String IPFhelper::selectDB( String logicalName, String protocol, String host )
{

    rules = "";
      // remember the record being accessed currently
    formLogicalName = logicalName;
    formProtocol = protocol;
    formHost = host;

    String sql = "SELECT LOGICAL_NAME, PROTOCOL, SERVICE_HOST, SERVICE_HOST_2, SERVICE_HOST_3, SERVICE_HOST_4, PORT_NO, IN_OR_OUT, ALLOW_DENY ";
    sql += " FROM SERVICE_ACCESS ";
    sql += " WHERE PROTOCOL = 'JDBCODBC' AND ALLOW_DENY = 'A'";
    //add the tuples for the identd FIX THIS
    sql += " UNION ";
    sql += "SELECT LOGICAL_NAME, PROTOCOL, SERVICE_HOST, SERVICE_HOST_2, SERVICE_HOST_3, SERVICE_HOST_4, PORT_NO, IN_OR_OUT, ALLOW_DENY ";
    sql += " FROM SERVICE_ACCESS ";
    sql += " WHERE PROTOCOL = 'TCPIP'";

    DBopDriver opd;
    DBRETVAL rc = opd.sql( (const char *)sql, 0, (DBackTupleHandler)getTupleHandler);  // execute the SQL statement
    if ( DBERROR( rc ) )
    {
      rules = "ERROR: ";
      rules += opd.getErrorMsg();
      CRERROR( ( const char * )rules );
    }

 CRDEBUG( CRinit, ( "IPFhelper::selectDB(): rules = %s ",(const char *)rules) );
    return rules;
}

// returns empty string if everything went ok
// otherwise returns error message
String IPFhelper::applyRules( String rules )
{
	String msg;
	String tempStr = HEADER;

#ifndef __linux
//read in custom ipf rules only for Solaris

	FILE *customFp;
	if((customFp = fopen( "/etc/ipf/custom.conf", "r" )) != NULL )
	{
		//Read the configuation from the file
		String  strBuffer;
		strBuffer.make_empty();
		//read file in strBuffer
		while( fgets(strBuffer, customFp) != NULL)
		{
			CRDEBUG_PRINT(0,("strBuffer = %s",(const char*) strBuffer));
			tempStr += strBuffer;
		}
		fclose(customFp);
	}

//end of reading custom rules
#endif

	tempStr += rules;
	tempStr += TAILER;

	// set the user mask, so ipf.conf's permissions are rw-r--r--
	umask( 0133 );  
	setuid( 0 );    // set the user id to root
	setgid( 0 );    // set the group id to root
	// generates the rule file
	FILE *fp = fopen( IPF_CONF, "w" );
	if ( fp == NULL )
	{
		msg = "Open/Create " IPF_CONF " failed, because: ";
		msg += strerror( errno );
		CRERROR( ( const char * )msg );
		return msg;
	}
	int retCode = fputs( ( const char * )tempStr, fp );
	if ( retCode == EOF )
	{
		msg = "Write to " IPF_CONF " failed, because: ";
		msg += strerror( errno );
		fclose( fp );
		remove( IPF_CONF );  // try to remove the corrupted file
		CRERROR( ( const char * )msg );
		return msg;
	}

	fclose( fp );

	/* IBM waynepar 20070313 SuSe Linux iptables support */
	/* For Solaris, ipf.conf is a config file read by ipf. */
	/* For Linux, iptables.conf is an executable script file */
	/* that executes iptable to set rules */
#ifdef __linux
	// set iptable rule script permissions to executable
	retCode = system( MKEXE );
	if ( retCode != 0 )
	{
		msg = "execute unix command '" MKEXE"' failed. To troubleshoot, execute this command manually under root privilege, and see what error happens.";
		CRERROR( ( const char * )msg );
		return msg;
	}
	// execute the iptable rule script
	retCode = system( APPLY_RULE );
	if ( retCode != 0 )
	{
		msg = "execute unix command '" APPLY_RULE"' failed. To troubleshoot, execute this command manually under root privilege, and see what error happens.";
		CRERROR( ( const char * )msg );
		return msg;
	}

#else
	// load the rule into ipfilter kernel
	// ONLY run this if ipfilter is running
	if( !INcheckStatusIpfilter())
	{
		return "ipfilter not running";
	}

	retCode = system( APPLY_RULE );
	if ( retCode != 0 )
	{
		msg = "execute unix command '" APPLY_RULE"' failed. To troubleshoot, execute this command manually under root privilege, and see what error happens.";
		CRERROR( ( const char * )msg );
		return msg;
	}
#endif
	/*IBM waynepar 20070313 end change */

	return msg;
}

  // returns the rules
  // if error happened, the returned string starts from "ERROR"
String IPFhelper::selectRep()
{

    repRules = "";

    String sql = "SELECT HOSTNAME, HOSTNAME2, INH ";
    sql += " FROM REPLICATION ";
    sql += " WHERE REP_TYPE='1'";
    DBopDriver opd;
    DBRETVAL rc = opd.sql( (const char *)sql, 0, (DBackTupleHandler)repTupleHandler);  // execute the SQL statement
    if ( DBERROR( rc ) )
    {
      repRules = "ERROR: ";
      repRules += opd.getErrorMsg();
      CRERROR( ( const char * )rules );
    }

    return repRules;
}
  // this is a callback function, it receives a tuple from DBopDriver
DBRETVAL repTupleHandler(DBuserOpTag tag, char*& retResult, DBtuple& tuple)
{
static char err[128];
    String host1 = tuple[ "HOSTNAME" ]->getValue();
    String host2 = tuple[ "HOSTNAME2" ]->getValue();

 CRDEBUG( CRinit, ( "IPFhelper::repTupleHandler(): host1 = %s, host2 = %s ",(const char *)host1,(const char *)host2) );
String tmpRule;
      // get the rules for this record
    tmpRule = IPFhelper::handleRepTblRecord( host1, host2 );
  if ( strncmp( ( const char * )tmpRule, "ERROR", 5 ) == 0 )
  {
 CRDEBUG( CRinit, ( "IPFhelper::repTupleHandler(): error tmpRule = %s ",(const char *)tmpRule) );
	 strncpy( err, ( const char * )tmpRule, 127 );
    retResult = err;
    return DBFAILURE;
  }
 CRDEBUG( CRinit, ( "IPFhelper::repTupleHandler(): tmpRule = %s ",(const char *)tmpRule) );
  if ( strncmp( ( const char * )tmpRule, "INVALID", 5 ) != 0 )
  {
    repRules+=tmpRule;
  }

 CRDEBUG( CRinit, ( "IPFhelper::repTupleHandler(): repRules = %s ",(const char *)repRules) );

    return DBSUCCESS;
}
/**********************************************************************
** Name: handleRepTblRecord
**
** Desc: This function will create the rules for the replication table
**		entry. It will take both of the hostnames, figure out which one
**      is the mate hostname and look in the etc/hosts file for it's 
**		ip addresses.
**********************************************************************/
String IPFhelper::handleRepTblRecord( String host1, String host2 )
{
	struct addrinfo *aip=NULL, *res=NULL;
	struct addrinfo hints;
	String lineStr="";
	String mate="";
	char mate1[50];
	String portno=TTPORT;
	String portno2=TTPORT2;
	String host;
	char tmphost[32];
        int rc;

	// if the hostnames are set to none then the system is not configured
	if ((host1==NONE)||(host2==NONE))
	{
      	lineStr = "INVALID: hostname";
		return lineStr;
	}
 CRDEBUG( CRinit, ( "IPFh::handleRepTblRecord(): host1 = %s, host2 = %s ",(const char *)host1,(const char *)host2) );
	// get a copy of the hostname
	 strncpy( tmphost, (const char * )host1, 31 );

 CRDEBUG( CRinit, ( "IPFh::handleRepTblRecord(): tmphost = %s",tmphost) );

	// need to figure out which hostname is belongs to the mate.
	if (localHost(tmphost))
	{
		mate=host2;
	}
	else
	{
		mate=host1;
	}
 CRDEBUG( CRinit, ( "IPFh::handleRepTblRecord(): mate = %s",(const char*)mate) );

	memset(&hints, 0, sizeof(hints));
        hints.ai_socktype = SOCK_STREAM;

        if ( rc=getaddrinfo((const char*)mate, portno, &hints, &res) != 0)
        {
                CRDEBUG(CRinit,("Host (%s) not found ->%s\n", (const char*)mate, gai_strerror(rc)));
      		lineStr = "INVALID: hostname=" + mate;
		return lineStr;
        }

	// Parsing out the different IP addresses
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	for ( aip = res; aip ; aip = aip->ai_next )
	{
		if (aip->ai_family != AF_INET && aip->ai_family != AF_INET6)
                        continue;

		if (getnameinfo(aip->ai_addr, aip->ai_addrlen,
                   ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST|NI_NUMERICSERV) 
		   != 0)
		{
                        continue;
		}
			
 		CRDEBUG(CRinit,( "IPFh::handleRepTblRecord(): host = %s", ntop ));
		host = ntop;

		RuleTuple temp( ( const char* ) host, ( const char* )portno, IN );

		if ( host != "" && ruleSet.find( temp ) == ruleSet.end() )
    		{
			lineStr += PASS_IN;
			lineStr += host;
			lineStr += TO;
			lineStr += ANY;
			lineStr += PORT;
			lineStr += portno;
			lineStr += "\n";
			ruleSet.insert( temp );
		}

		RuleTuple temp1( ( const char* )host, ( const char* )portno, OUT );

		if ( host != "" && ruleSet.find( temp1 ) == ruleSet.end() )
		{
			lineStr += PASS_OUT;
			lineStr += ANY;
			lineStr += TO;
			lineStr += host;
			lineStr += PORT;
			lineStr += portno;
			lineStr += "\n";
			ruleSet.insert( temp1 );
		}

		RuleTuple temp2( ( const char* )host, ( const char* )portno2, IN );

		if ( host != "" && ruleSet.find( temp2 ) == ruleSet.end() )
    		{
			lineStr += PASS_IN;
			lineStr += host;
			lineStr += TO;
			lineStr += ANY;
			lineStr += PORT;
			lineStr += portno2;
			lineStr += "\n";
			ruleSet.insert( temp2 );
		}

		RuleTuple temp3( ( const char* )host, ( const char* )portno2, OUT );

		if ( host != "" && ruleSet.find( temp3 ) == ruleSet.end() )
		{
			lineStr += PASS_OUT;
			lineStr += ANY;
			lineStr += TO;
			lineStr += host;
			lineStr += PORT;
			lineStr += portno2;
			lineStr += "\n";
			ruleSet.insert( temp3 );
		}
	}
	freeaddrinfo(res);

  return lineStr;

}

  // return true if it is a local hostname
  // otherwise return false
bool IPFhelper::localHost( char* hostname )
{
  if ( hostname == 0 )
    return false;

    // get the official local host name first
  char officialname[ 1024 ];
  if ( gethostname( officialname, sizeof( officialname ) ) != 0 )
    return false;

    // get the name and aliases associated with the offical local host name
  std::string names = getHostNameAndAliases( officialname );
  std::string target = " ";
  target += hostname;
  target += " ";

    // check if the target hostname is contained in the name and aliases
  if ( names.find( target ) != std::string::npos )
    return true;  // found

    // check if the official local host name is the alias of the target hostname
  names = getHostNameAndAliases( hostname );
  target = " ";
  target += officialname;
  target += " ";
  if ( names.find( target ) != std::string::npos )
    return true;  // found
  else
    return false;  // not found
}

  // return a string which contains
  // if there is error, it will return a string contain one space
  // hostname and aliases are space-separated
std::string IPFhelper::getHostNameAndAliases( char* hostname )
{
  std::string temp = " ";
  if ( hostname == 0 )
    return temp;

  hostent result;
  char buf[ 4096 ];  // this buffer size is large enough
  hostent *ent;

  gethostbyname_r( hostname, &result, buf, sizeof( buf ), &ent, &h_errno );

  if ( ent == NULL )
    return temp;
  if ( (result.h_addrtype != AF_INET) && (result.h_addrtype != AF_INET6) )
    return temp;
  temp += result.h_name;
  temp += " ";
  char **pptr;
  for ( pptr = result.h_aliases; *pptr != NULL; pptr++ )
  {
    temp += *pptr;
    temp += " ";
  }

  return temp;
}

Bool
INcheckStatusIpfilter()
{
	FILE *theFileFp, *theErrorFp, *thePipeFp, *theStderrFp;

	String theCmdStr="/usr/bin/svcs | grep ipfilter | cut -f1 -d\" \"";
        String outputText;
	String returnValue = "";
        String tmpfname = tmpnam(NULL);

        const int maxLineLen = 1000;
	int i =1;

        char linebuf[maxLineLen+1];
        char errbuf[maxLineLen+1];

	memset(linebuf,0, sizeof(linebuf));
        memset(errbuf,0, sizeof(errbuf));

        CRDEBUG(0,("The command string =\n<%s>\n", (const char*)theCmdStr));
        /*
        ** create file to trap stderr output from /bin/sh
        ** If the user tries to execute a non-existant command
        ** /bin/sh will print a message on stderr
        */
	theStderrFp = freopen( tmpfname, "w", stderr);
        if (theStderrFp == NULL)
        {
                CRERROR("redirection of stderr to '%s' failed (errno=%d)", 
			(const char*)tmpfname, errno);

        }
	fclose(theStderrFp);

        thePipeFp = popen(theCmdStr, "r");
        if (thePipeFp == NULL)
        {
                fclose(theErrorFp);
                pclose(thePipeFp);
                unlink(tmpfname);
                returnValue="FAILED : popen of" + theCmdStr;
                CRERROR("Fail to run  %s Error was : %s",
			(const char*) theCmdStr, returnValue);
		return DOWN;
        }

        while (fgets(linebuf, sizeof(linebuf)-1, thePipeFp))
        {
                returnValue=returnValue+linebuf;
                CRDEBUG(0,("linebuf = %s", linebuf));
        }
        pclose(thePipeFp);

        errbuf[0]=NULL;

        theErrorFp=fopen( tmpfname,"r");

        while (fgets(errbuf, sizeof(errbuf)-1, theErrorFp))
        {
                //break;
        }
        fclose(theErrorFp);

        if(errbuf[0] != NULL)
        {
                returnValue = "FAILED :";
                returnValue =+ errbuf;
                CRERROR("Fail to run  %s Error was : %s", 
			(const char*)theCmdStr, returnValue);
		return DOWN;
        }

        CRDEBUG(0,("returnValue = >%s<",(const char*)returnValue));

	if(returnValue.chunk(0,6) == "online") //enable
	{
		return UP;
	}

	return DOWN;

}//end of INcheckStatusIpfilter
